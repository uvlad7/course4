## Lab 1

### Как это работает:

1. Шифруем текст. Вообще шифрование работает, сохраняя кейс шифруемых символов и оставляя неизменными неалфавитные символы, но для простоты вспомогательная функция, берущяя рандомный кусок текста, ещё и делает апкейс и заменяет неалфавитные символы пробелами.

2. Ищем n-граммы. Ищутся все повторяющиеся, для оптимизации n-граммы ищутся только на позициях, на которых были найдены n-1-граммы. Сохраняются в хеш со структурой { n-gram => { count: count, pos: [array_of_start_positions] } }. После каждой итерации удаляются пары, для которых count == 1, т. е. нет повторений (метод delete_if модифицирует оригинальный хеш, будьте осторожны при изменении логики!), дальше итерируемся только по оставшимся стартовым позициям.
Получаем хэш вида { расстояние => степень_доверия }. Степень доверия считается как сумма логарифмов длин n-грамм, между которыми есть такое расстояние (берутся только соседние, т. к. для НОД остальные не важны). Преподу такая весовая функция не очень понравилась, идея была в том, чтобы она слабо изменялась при больших длинах, а плохо то, что функция слабо меняется для значительного изменения при маленьких длинах, например Math.log(30) / Math.log(2) ~= 5, но случайное совпадение 5 последовательностей длины 2 явно вероятнее одной длины 30. Вынесено в один метод, т. к. самая тяжёлая часть и результат можно переиспользовать для разных значений threshold, а промежуточный результат - n-граммы - переиспользовать невозможно.

3. Ищем длину ключа. Убираем расстояния, для которых степень доверия меньше максимальной * threshold, находим НОД оставшихся значений (или 1, если вдруг хеш пустой)

4. Находим ключ. Для поиска ключа шифра Цезаря ищем частоты букв в шифротексте и для всех возможных ключей находим по всем буквам сумму квадратов разностей стандартой частоты и частоты в расшифрованном этим ключом тексте. В качестве ответа возвращаем ключ, для которого сумма минимальна. Такой подход показывает себя хорошо и даже если в качестве длины мы нашли число, кратное реальной длине, в ответе обычно получается ключ, состоящий из повторов настоящего.

5. Экспериментируем. Эксперимент с переменной длиной текста и переменной длиной ключа, в обоих случаях на каждую комбинацию длин берется по 10 различных случайных отрывков текста и случайных ключей. Потом перебираем различные threshold-ы, чтобы найти оптимальный, у меня получилось 40%, когда поменяете весовую функцию, оптимальное значение поменяется. Результат выводится на 3D графике.

### Как это не работает:

Не пытайтесь повторить отрисовку графиков через ruby. Разбирался, почему не работает pycall, я примерно сутки, просто не для этой лабы. К тому же изначально идея была сделать всё интерактивно и отображать прогресс эксперимента прямо на графике. Однако для этого нужно интерактивное окружение для matplotlib, которое настроить у меня так и не получилось, иначе графики будут зависать. В итоге пришлось сохранить 3D графики в картинки, т. к. вызов pyplot.show в неинтерактивном режиме блокирует выполнение, пока окно открыто, преподу это не понравилось. Можно или сохранить данные в csv и в отдельной программе их визуализировать, или сначала найти оптимальный threshold и экспериментировать с ним, сохраняя всё картинками.