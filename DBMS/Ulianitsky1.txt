--Выбирите СУБД Oracle для выполнения лабораторной. 
--Cкопируйте файл EDU1.sql в каталог C:\TEMP .
--Раскройте файл и ознакомтесь со скриптом создания и заполнения таблиц для выполнения лабораторной.
-- Произведите запуск SQLPlus. или PLSQLDeveloper. или другого инструментария Oracle и соеденитесь с БД.  Запустите скрипт EDU.sql на выполнение.
--Вставте в эту строку Ваши ФИО, номер группы, курса. ФИО Ульяницкий В. А., группа 1, курс 4.      
--Файл с отчётом о выполнении лабораторной создаётся путём вставки соответсвующего select-предложения после строки с текстом задания. 
--Файл отчёта именуется фамилией студента  в английской транскрипции, с расширением .txt и отправте в систему edufpmi как ответ к заданию или сохраните в каталоге fpmi-serv604\common-stud\Исаченко\гр2. 
--Тексты заданий:
--1.	Выдать информацию об дате рождения работника Robert Grishuk.

SELECT TO_CHAR(birthdate, 'YYYY-MM-DD') as robert_grishuk_birthdate FROM emp WHERE empname = 'Robert Grishuk' and ROWNUM = 1;

--2.	Выдать информацию обо всех работниках, родившихся в период с 1.01.1980 по 31.12.1982.

SELECT * FROM emp WHERE birthdate BETWEEN DATE '1980-01-01' AND DATE '1982-12-31';

--3.	Найти минимальный оклад, предусмотренный для бухгалтера  (Accountant).

SELECT minsalary FROM job WHERE jobname = 'Accountant' and ROWNUM = 1;

--4.	Подсчитать число работников, работавших в компании до 31 мая 2016 года включительно хотя бы один день.

SELECT COUNT(*) as workers_count FROM career WHERE startdate <= DATE '2016-05-31';

--5.	Найти масимальные премии, начисленные в 2016, 2017, 2018, 2019 годах (указать год и максимальную премию в хронологическом порядке).

SELECT year, max(bonvalue) as max_bonus FROM bonus WHERE year >= '2016' and year <= '2019' GROUP BY year ORDER BY year;

--6.	Выдать информацию о кодах отделов,  в которых работал работник Robert Grishuk. Если Robert Grishuk работает в настоящее время - отдел также включается в искомый список.

SELECT DISTINCT deptid FROM career JOIN emp ON career.empno = emp.empno WHERE emp.empname = 'Robert Grishuk';

--7.	Выдать информацию о названиях должностей,  на которых работали работники Vera Rovdo и Dave Hollander. Если один из них или оба  работают в настоящее время - должность также включается в искомый список. 
--	Должность выдаётся вместе с ФИО (empname) работника.

SELECT DISTINCT empname, jobname
FROM job
         JOIN career ON career.jobno = job.jobno
         JOIN emp ON career.empno = emp.empno
WHERE emp.empname IN ('Vera Rovdo', 'Dave Hollander');

-- 8.	Найти фамилии, коды должностей, периоды времени (даты приема и даты увольнения) для всех инженеров (Engineer) и программистов (Programmer), работавших или работающих в компании. Если работник работает
--	в настоящий момент, то дата увольнения должна выдаваться как Null.

SELECT emp.empname, career.jobno, career.startdate, career.enddate
FROM emp
         JOIN career ON emp.empno = career.empno
         JOIN job ON job.jobno = career.jobno
WHERE job.jobname IN ('Engineer', 'Programmer');

-- 9.	Найти фамилии, названия должностей, периоды времени (даты приема и даты увольнения) для бухгалтеров (Accountant) и продавцов (Salesman),  работавших или работающих в компании. Если работник работает
--	в настоящий момент, то дата увольнения отсутствует.

SELECT emp.empname, job.jobname, career.startdate, career.enddate
FROM emp
         JOIN career ON emp.empno = career.empno
         JOIN job ON job.jobno = career.jobno
WHERE job.jobname in ('Salesman', 'Accountant');

-- 10.	Найти количество различных работников, работавших в отделе B02 хотя бы один день в период с 01.01.2015 по настоящий момент.

SELECT count(DISTINCT empno) as b02_workers_count
FROM career
WHERE (deptid = 'B02' AND startdate <= (SELECT CURRENT_DATE FROM DUAL) AND
       (enddate >= DATE '2015-01-01' OR enddate IS NULL));

-- 11.	Найти фамилии этих работников.

SELECT DISTINCT emp.empname
FROM emp
         JOIN career ON emp.empno = career.empno
WHERE (deptid = 'B02' AND startdate <= (SELECT CURRENT_DATE FROM DUAL) AND
       (enddate >= DATE '2015-01-01' OR enddate IS NULL));

--12.	Найти номера и названия отделов, в которых в период с 01.01.2019 по 31.12.2019  работало не более пяти работников.

SELECT DISTINCT dept.deptid, dept.deptname
FROM dept
WHERE (SELECT count(*)
       FROM career
       WHERE (career.deptid = dept.deptid
           AND career.startdate <= DATE '2019-12-31'
           AND (career.enddate >= DATE '2019-01-01' OR career.enddate IS NULL))) <= 5;

--13.	Найти информацию об отделах (номер, название), всем работникам которых не начислялась премия в период с 01.01.2019 по  31.12.2019.


--14.	Найти количество работников, никогда не работавших и не работающих в исследовательском  (Research) отделе, но работавших или работающих в отделе поддержки (Support). 

SELECT count(DISTINCT emp.empno) as workers_count
FROM emp
WHERE (SELECT count(*)
       FROM career
                JOIN dept ON dept.deptid = career.deptid
       WHERE career.empno = emp.empno
         AND dept.deptname = 'Research') = 0
  and (SELECT count(*)
       FROM career
                JOIN dept ON dept.deptid = career.deptid
       WHERE career.empno = emp.empno
         AND dept.deptname = 'Support') > 0;

-- 15	Найти коды и фамилии работников, работавших в двух и более отделах, но не работающих в настоящее время в компании.

SELECT DISTINCT emp.empno, emp.empname
FROM career
         JOIN emp ON career.empno = emp.empno
WHERE (SELECT count(DISTINCT deptid)
       FROM career
       WHERE career.empno = emp.empno) >= 2
  and (SELECT count(*)
       FROM career
       WHERE career.empno = emp.empno
         AND enddate IS NULL) = 0;

-- 16	Найти коды и фамилии работников, работавших в двух и более должностях, но не работающих в настоящее время в компании.

SELECT DISTINCT emp.empno, emp.empname
FROM emp
         JOIN career ON career.empno = emp.empno
WHERE (SELECT count(DISTINCT jobno)
       FROM career
       WHERE career.empno = emp.empno) >= 2
  and (SELECT count(*)
       FROM career
       WHERE career.empno = emp.empno
         AND enddate IS NULL) = 0;

-- 17	Найти коды  и фамилии работников, суммарный стаж работы которых в компании на текущий момент не более 8 лет.

SELECT emp.empno, emp.empname
FROM emp
         JOIN career ON emp.empno = career.empno
GROUP BY emp.empno, empname
HAVING sum((NVL(enddate, (SELECT CURRENT_DATE FROM DUAL)) + 0) - (startdate + 0)) <= 8 * 365;

-- 18	Найти всех работников (коды и фамилии), увольнявшихся хотя бы один раз.

SELECT DISTINCT emp.empno, emp.empname
FROM emp
         JOIN career ON career.empno = emp.empno
WHERE (SELECT count(*)
       FROM career
       WHERE career.empno = emp.empno
         AND enddate IS NOT NULL) > 0;

--19.	Найти среднии премии, начисленные за период в три 2016, 2017, 2018 года, и за период в три 2017, 2018, 2019 года, в разрезе работников (т.е. для работников, имевших начисления хотя бы в одном месяце трёхгодичного периода). 
--	Вывести id, имя и фимилию работника, период, среднюю премию.

SELECT emp.empno, emp.empname, '2016, 2017, 2018' AS years, avg(bonvalue) AS avg_bonus
FROM bonus
         JOIN emp on emp.empno = bonus.empno
WHERE year IN (2016, 2017, 2018)
GROUP BY (emp.empno, emp.empname)
UNION
(SELECT emp.empno, emp.empname, '2017, 2018, 2019' AS years, avg(bonvalue) AS avg_bonus
 FROM bonus
          JOIN emp on emp.empno = bonus.empno
 WHERE year IN (2017, 2018, 2019)
 GROUP BY (emp.empno, emp.empname));

--20.	Найти отделы (id, название, адрес), в которых есть начисления премий в апреле и марте 2019 года.

SELECT DISTINCT dept.deptid, dept.deptname, dept.deptaddress
FROM dept
WHERE (SELECT COUNT(*)
       FROM (career
                JOIN bonus ON career.empno = bonus.empno)
       WHERE bonus.year = 2019
         AND bonus.month IN (4, 3)
         AND career.deptid = dept.deptid) > 0;